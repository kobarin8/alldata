20180730

アルゴリズムとは
コンピュータは頭が固く、命令されたままに従って動作する。よって、
プログラミングにおける最大の重要課題は、

どのような命令を

どのような順序で行うかである。

間違った命令を与えれば、コンピュータは疑うことなくそのまま間違った動作をしてしまう。

例えば、ロボットにある地点まで道案内をするとする。
「しばらくまっすぐ→右へ曲がって→次に左に曲がって進め」
としなければいけないところを、「左→右」と命令しては
残念ながら目的地には着かない。
プログラミングのやっかいなところは、
予め全ての命令を書き出しておかなければいけないところである。
例えば、上記のロボットの道案内の例で途中工事が行われていても、
進めと予め与えられた命令はそのまま実行されてしまう。
もし迂回させたいのであれば、あらかじめそのように命令を与えておかなければいけない。
このようにプログラムは全ての場合を想定して、一連の命令を与えておかなければいけない。
つまりある仕事をコンピュータにさせる場合、
どのような手順で作業をしていかなければいけないのかを考え、
記述しておかなければならない。
このような一連の手順のことをアルゴリズム（algorithm）と呼び、日本語では「計算手順」と呼ばれている。
プログラムを作る、つまりアルゴリズムを考えるのは人間であり、
コンピュータはそれにしたがってただ単に実行するだけである。
よって、人間がすばらしいアルゴリズムを考え、
それをコンピュータに与えれば、コンピュータは素晴らしい動きをしてくれる。
一方しょぼいアルゴリズムしかプログラマが考えられなかったとすると、
残念ながらしょぼいコンピュータとなってしまう。

http://www.cs.t-kougei.ac.jp/hif/lecture/program-bas/A/pro-bas.html

第一回の連載でRedCoderの実力について触れましたが、
筆者の肌感覚でレベルを表すと、
小学生までの算数の知識で解ける問題をこなすことができればYellowCoderに、
中学生までの数学の知識で解ける問題をこなせればRedCoderになるのはそう難しいことではありません。
しかし、現実はそうではありません。数十万人が登録しているTopCoderですが、
RedCoderはたった数百人しか存在していないのです。これはなぜなのでしょう？

答えは簡単です。

小・中学生までの知識で十分に解ける問題でも、
どう解くかを思いつかなければ、その問題を解くことができないからです。

ここまで書けばお分かりかと思いますが、問題を解く上で必要なのは、

“柔軟な発想力”であり、“有名なアルゴリズムを詰め込むこと”ではないのです。



積み上げるのは“知識”よりも“経験”
さて、ここまでで「問題を解く上で必要なのは“柔軟な発想力”であり、
“有名なアルゴリズムを詰め込むこと”ではない」と述べてきました。
それでは「柔軟な発想力」というものはどうすれば身につくのでしょうか？　
これは非常に難しい命題であり、意見が分かれるところでもありますが、ここでは筆者の見解を示します。

柔軟な発想とは何かを考える前に、
「発想」とはそもそも何なのかを考えてみましょう。
筆者は「発想」とは、「経験から一歩先のアイデアを導き出すこと」だと考えます。
どんなに才能豊かな人物であっても数字を知らなければ計算はできませんし、
生まれたばかりの何も知らない状態では言葉を話すことはできません。
これと同じく、経験がなければ、問題を解くための発想が出てくるはずがないのです。

経験は単なる知識を凌駕するのです。

それでは結局のところ、典型的なアルゴリズムを詰め込んでいくしかないではないか、と思う人も多いでしょう。

しかし、それは違います。
まったく経験をせずに、単なる“知識”として詰め込んだものは、現実にはほとんど役に立ちません。

例えば、高速フーリエ変換の仕組みだけを突然教えられたとして、
「これは多倍長整数の乗算の高速化に使える！」と発想できる人がどれだけいるでしょう？　
要するに、訳の分からない知識をいきなり詰め込まれても、実際にその知識を使ってそれがどう凄いのかを体験しない限り、
その知識を活用することはできない、ということです。

そして、経験というのは、さまざまな場面で積むことができます。
TopCoderのような大会しかり、趣味・仕事などで行っている開発、情報系とあまり関係ない
数学ないしは算数の問題の経験なども、関連性の大小はあるものの、十分にここでいう経験に当てはまるものです。

こうしたコンセプトに基づいて本連載は書き進めていますので、
実際にコードを書いて、経験をする、といったことを強く推奨します。
TopCoderの過去問題というのは、あの手この手で参加者を悩ませようとしているため、
さまざまな経験を積むのに適しています。

可能な限り自力で考え、

自らの答えを出してから解説に入るのがよいのですが、それができないにしても、

自分で方針などを考えた後に解説を読むのと、何も考えずに解説を読んだのでは、得られる経験は大幅に変わってきます。

また、解説を読んだ後に書かれたソースを写したり、別の言語で書き換えたりするだけでも、大きな効果が得られると考えます。


とにかく初心者だからこそ自分のレベルでできることは全てマスターしておくことが大事です。

科学館やイベントで一時的に科学に対する関心や面白さを喚起しても、持続できずに結果として関心が失せてしまう

プログラミングが上達する方法その3 ミニアプリを作ってみる
上述のアンチパターンを知るのと同時に、簡単なミニアプリを作ってプログラミングの練習をしましょう。

ここでおすすめなのは、次のようなプログラムを書くことです。

FizzBuzz
→基本的な条件分岐の使い方。
バブルソート
→int配列の並べ替え。
既存のコマンドを自作する
→例えばcatコマンド(ファイルの内容を標準出力(コマンドプロンプトなど)に表示する)を自作してみる。
→もちろん、コマンドオプションにもできる限り対応する。
バイナリダンプ
→ファイルの内容を1バイト毎に16進数で表示する。
→やはりコマンドオプションを付与することで、1行8バイト/16バイト/32バイトを切り替えたり、
ASCII文字の表示/非表示を切り替えたりなど。その他諸々・・・
まあ何と言うか、条件分岐のように基本的なところから、
プログラマー業界ではいわゆる「車輪の再発明」と呼ばれるところまでを、ここではあえて行います。
そうすることで自分で1からロジックを考える能力や、
知らないことを自力で調べる能力などが付くと私は思っています。

https://taiyoproject.com/post-339

実用性の有無は置いといて、こういった多少手の込んだアプリを1人で作れるようになれば、もうあなたは立派なプログラマーですよ。

一度教本から外れて自分の知識と想像力だけで何かを作ってみてはいかがでしょうか？
それで思った通りに作れれば少なからず上達はしているのでしょうし、全く手も足もでなければそれを実装するためには何が必要なのか・足りないのかが明確になるかと思いますよ。

カリキュラムをこなすだけではなく、カリキュラムで覚えたことを使って自分の目標を設定・達成してみてください。


車輪の再発明をしようとした結果、失敗をすることもあるでしょう。
しかし、それは一度で車輪の再実装がうまくいくよりも貴重な体験になるはずです。
自分の予でゼロからコードを書き、あれこれと試行錯誤をすることを通して学ぶのは、
ただ技術を読んで学ぶこととは大きく違います。
試行錯誤をしている間は、悔しがったり喜んだり、感情が大きく動くことになるからです。
本を読むなどして知識を頭に入れることも大切です。
しかし優れたプログラマになるためには、経験を積むことがどうしても必要です。
現場で多くを見て、自分の手で何かを作ることが必要なのです。
車輪の再発明は、プログラマが学び、技術を高める上で非常に重要なことです。
ボディビルダーがバーベルを上げるのと同じよろなもの、と言ってもいいでしょう。


「集中的訓練 (Deliberate practice：DP)」という言葉があります。
集中的訓練は、ただ課題をこなすだけのものではありません。
「課題のための課題」、課題を終わらせるためだけに課題をやっているのだとしたら、
それはまったく集中的訓練とは呼べないでしょう。
集中的訓練の目的は、あくまで自らの能力を高めることにあります。
いわゆる「スキル」や「テクニック」を身につけることが目的なのです。
集中的訓練において重要なのが「反復」です。
身につけたい能力をいくつかの小さな要素に分割し、
その一つ一つについて反復訓練をし、習熟度を高めていきます。
つまり「反復の反復」が必要になる、ということです。
ゆっくりと、能力全体の習熟度を望ましいレベルにまで引き上げていきます。
集中的訓練の目的は習熟度を上げることであり、

個々の課題、作業をこなし、完了することではないのです。

集中的訓練は、専門技術を身につける上で、欠かせないものだ。
ただ反復訓練をすればいいというのではなく、
自分の現在の能力を少し越える課題に取り組むことが重要である。
それで自分の限界を引き上げるのだ。
困難な課題に挑戦し、その結果をよく分析し、なにか失敗すれば修正する、その繰り返しである。

入念に計画された訓練では得意なことに取り組むのではない。
自分を鍛え、少なくともまだ得意ではないことに取り組むのである。楽しいとは限らない。

https://xn--97-273ae6a4irb6e2hsoiozc2g4b8082p.com/%E3%82%A8%E3%83%83%E3%82%BB%E3%82%A4/1%E4%B8%87%E6%99%82%E9%96%93%E3%81%AE%E8%A8%93%E7%B7%B4/

本当に身につけたい技術は、コードを自ら書き、手を動かして学ぶ。

「達人プログラマ」を読み、学んだことを実践してみる。
本の教えに従い、毎年1つ新しい言語を学ぶ。
たとえ言語が無理でも、少なくとも毎年1つは新しい技術、ツールについて学ぶ。
そうして未知のものに触れることは、新たな発想の元になる。


分がいま取り組んで、いる作業の内容を完全に把握していました。
作業ではどのファイルについて何をするのか、
何時間で完了する予定なのか、それがすべて明確になっていました。

最初の2人は、何も大局を見ていなかったわけではないのです。
最終的な目標が何なのかはよくわかっていました。
その目標に向かつて前進するために、今どんな作業をすべきかを明確に決めていただけです。
すべきことをはっきりと定め、それを何時間で完了させるのかも定めていました。
また、1つの作業が完了したら、すぐに次に何をすればいいかを決めます。

大目標を小目標に分解するということは一切していません。
いきなり大目標に向かつて作業を始め、漠然と作業を進めていました。
目標達成までに具体的にどういう作業が必要になるのか、
それぞれにどのくらい時間がかかるのかはまったく見えておらず、
次にどうすればいいかは手探りで何となく決めている、という状態です。
そうしているうちに視界が開け、すべきことが明確になり始めるだろう、とは思っていますが、
それがいつになるか確信はありません。
おそらく最初の万に書いたコードは、長い時間が経って全体像が見えてくる頃には、
まったく的外れなものだったことがわかるでしょう。

大事なのは、常に自分が何をすべきかを明確にするということです。
完了する期限も必ず決めます。もし、期限内に予定の作業が終わらないようであれば、
その間に書いたコード、コードに加えた変更はすべて破棄します。
再度、小目標を立て直して作業内容を検討し、はじめからやり直すのです。
次に何をすればいいかがすぐにわからない時は、やはりあれこれと模索するのですが、

大事なのは「いつの間にか手探り状態になっていた」ということを絶対に避けるということです。

模索段階で、書いたコードを決してレポジトリに入れてはいけません。

コンピュータが自動でやってくれることなどほとんどなく、あとは自分の手でやるしかないのです。
プログラミングとは元々そういうものだったはずです。